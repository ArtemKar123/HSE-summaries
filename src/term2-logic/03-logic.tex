\Subsection{Высказывания}

Начало пропущено, но оно простое.

Высказывание --- утверждение, которое может быть ложным или истинным.

Тут был кек про Юрия Зайцева и про то, как из ложного утверждения следует всё, что угодно. 

\begin{definition}
Пропозициональная переменная --- произвольная переменная, обозначаем $x, y, z$, могут принимать значения 0 или 1
\end{definition}

\begin{definition}
Формула: 

\begin{enumerate}
	\item{Пропозициональная переменная является формулой}

	\item{Если $A$ --- формула, то $\lnot A$ --- тоже формула (отрицание)}

	\item{Если есть формулы $A, B$, то $(A \cap B), (A \cup B), (A \to B)$ --- тоже формулы}

\end{enumerate}

Минимальный класс строк, удовлетворяющий $*$ (предыдущей тройке утверждений), называется множеством формул.

\end{definition}

Теперь хотим давать значения формулам. Для переменной значение формулы есть просто значение переменной. Отрицание работает как отрицание, логические операции работают согласно таблице истинности (которая очевидна)

Для отсутствия проблем с порядком вычисления у нас есть скобки.

\begin{theorem}
	Любая формула допускает единственный разбор.
\end{theorem}
\begin{proof}
	Когда у нас есть формула, мы однозначно попадаем в один из трёх вариантов. Формально говоря --- посмотрим первый символ. Если это переменная, то мы завершаемся, если отрицание --- отрицаем и убираем отрицание, если открывающая скобка --- то в общем там можно найти операцию, в которой скобоный баланс равен единице и порвать по этой операции и уйти рекурсивно с двумя меньшими строками.
\end{proof}

\begin{definition}
	Тавтология --- формула, истинная при любых значениях переменных. Например $x \cup \lnot x$, или $(p \to q) \cup (q \to p)$
\end{definition}
\begin{definition}
	Две формулы $F_1, F_2$ эквивалентны, если $F_1$ истинно тогда и только тогда, когда $F_2$ истинно.
\end{definition}

На самом деле $F_1, F_2$ эквивалентны тогда и только тогда, когда $(F_1 \to F_2) \land (F_2 \to F_1)$ является тавтологией

\begin{definition}
	$A \leftrightarrow B = (A \to B) \land (B \to A)$ 
\end{definition}

\begin{theorem}
	Следующие формулы являются тавтологиями:
	\begin{itemize}
		\item{$(p \land q) \leftrightarrow (q \land p)$}
		\item{$((p \land q) \land r) \leftrightarrow (p \land (q \land r))$}
		\item{$  \lnot (p \land q) \leftrightarrow (\lnot p \lor \lnot q) $}
		\item{$\lnot (p \lor q) \leftrightarrow (\lnot p \land \lnot q)$}
		\item{$p \lor (p \land q) \leftrightarrow p$}
		\item{$p \land (p \lor q) \leftrightarrow p$}
		\item{$(p \to q) \leftrightarrow (\not q \to \not p)$}
		\item{$p \land (q \lor r) \leftrightarrow (p \land q) \lor (p \land r)$}
		\item{$p \lor (q \land r) \leftrightarrow (p \lor q) \land (p \lor r)$}
	\end{itemize}
\end{theorem}

\begin{theorem}
	Пускай есть $f : B^n \to B$ (из битовых строк длины $n$ в истину/ложь). Утверждение --- любая такая $f$ представляется используя $\land, \lor $ и $\lnot$, и, мало того, представляется в виде ДНФ: дизъюнктивно-нормальная формула.
\end{theorem}

\begin{definition}
	Конъюнкт --- $(x_{i1} \land x_{i2} \land \cdots \land x_{ik})$ --- набор логических И, возможно с отрицаниями.
	\end{definition}

\begin{definition}
	ДНФ --- дизъюнкция конъюнктов --- набор конъюнктов, объединённых логическим ИЛИ.
\end{definition}

\begin{proof}
	Докажем предыдущую теорему.

	Рассмотрим все наборы переменных и значения $f$ на них (рассмотрим таблицу истинности $f$). Выберем строки, в которых $f = 1$, тогда возьмём переменные оттуда и составим из них конъюнкт --- каждую переменную, если она со значением 0, то возьмём в конъюнкт её отрицание, а если со значение 1 --- возьмём саму переменную. Тогда полученный конъюнкт будет верен только и только на этом наборе переменных.

	Взяв все такие конъюнкты, на наборах переменных которых $f$ истинна, и объединив их через логическое ИЛИ, получим как раз ДНФ, истинную только на тех наборах переменных, на которых была истинна $f$. 
\end{proof}
\begin{example}
	Если кто хочет --- можете нарисовать тут таблицу истинности для формулы от трёх переменных и построить по ней описанным алгоритмом ДНФ. 
\end{example}

\begin{definition}
	КНФ --- конъюнкция дизъюнктов --- набор дизъюнктов (объединений переменных через $\lor$), объединённых через логическое И (выполняться должны все скобки).
\end{definition}

\begin{theorem}
	Для любой формулы можно построить КНФ. Строится аналогично, но выбираем строки с нулём. 
\end{theorem}

КНФ/ДНФ не единственны, и построенные нами не обязательно минимальны. 

Можно ли используя другие связки тоже выразить всё? 

Давайте выразим всё через $1, \oplus, \land$. 

\begin{definition}
	Одночлен Жегалкина --- $1, x, x \land y, x \land y \land w$
\end{definition}

\begin{definition}
	Многочлен Жегалкина: набор одночленов Жегалкина, объединённых $\oplus$
\end{definition}

\begin{theorem}
	Любая функция $f : B^n \to B$ допускает ровно одно представление в виде полинома Жегалкина. 
\end{theorem}

\begin{proof}
	Любой многочлен можно свести к многочлену Жегалкина: $x^2y \oplus xy \oplus xy = xy \oplus xy \oplus xy = xy$. Единственность --- при использовании каждого одночлена не более раза. 

	Мы знаем, что используя $\lnot, \lor, \land$ можно записать все формулы. А сами эти операции можно выразить следующим образом: $\lnot x = x \oplus 1; x \lor y = xy \oplus x \oplus y; x \land y = x \land y$.
\end{proof}
\begin{example}
	Если сильно нужен --- напишите, добавлю. Можете и сами добавить...
\end{example}
\begin{proof}[Единственность представления]
	У нас бывает $2^n$ одночленов (переменная или входит или не входит). Многочлен это набор одночленов, тогда многочленов $2^{2^n}$, но и всех функций $2^{2^n}$, и при этом каждой функции соответствует хотя-бы один многочлен, а тогда, т.к. функций столько же, сколько и многочленов, каждой функции соответствует ровно один многочлен.
\end{proof}

Пусть у нас есть произвольная тернарная функция $f(x, y, z)$ и $\land$. Можем ли мы представить любую функцию таким интересным набором? Хотим иметь критерий на этот счёт. 

Займёмся классами функций
\begin{definition}
	Сохраняющие ноль функции --- функция от всех нулей выдаёт ноль. Пример --- тождественный ноль, логическое или.

	Сохраняющие единицу функции --- функция от всех единиц выдаёт единицу. Пример --- тождественная единица, логическое или.

	Отрицание не является ни сохраняющей единицу, ни сохраняющей ноль.

	Монотонные функции --- от увеличения (замены нуля на единицу) любого из параметров значение функции не уменьшается. 

	Линейные функции --- те, для которых многочлен Жегалкина состоит только из $\oplus$ переменных и единиц, иначе говоря, в многочлене Жегалкина которых нет слагаемых степени больше единицы.

	Самодвойственные --- отрицание всех переменных влечёт отрицание значения функции. 
\end{definition}

\begin{example}
	$\land$ --- сохраняющая ноль, сохраняющая единицу, монотонная, не самодвойственная функция. 
	
	Тождественная функция является самодвойственной. 
\end{example}

\begin{theorem}[Теорема Поста]
	Набор функций является полным (можно представить любую функцию) тогда и только тогда, когда для любого класса из пяти названных существует $f_i$, не лежащее в этом классе.
\end{theorem}
\begin{proof}
	Если нет класса, в котором не лежит хотя-бы одна функция, то мы проиграли, т.к. не сможем выразить какую-либо функцию не из этого класса. Например, любая комбинация сохраняющих ноль/единицу функций тоже является сохраняющей ноль/единицу функцией, и тогда отрицание мы не выразим.

	Аналогично с монотонностью --- комбинация монотонных функций монотонна. Изменили увеличили какие-то переменные, функции, в которых они были могли только увеличиться, те функции, в которых эти функции как аргументы тоже могли только увеличиться и так далее... В общем, отрицание снова не получим. 

	Самодвойственность аналогичным образом проходит внутрь, к аргументам функций, которые если тоже функции, то отрицание тоже пройдёт внутрь и так далее, пока не проотрицаем все аргументы, что и есть самодвойственность. 

	И с линейностью так же будет, но в общем лекция закончилась, теорему доказать не успели.
\end{proof}

\begin{proof}
	...функций от одного аргумента четыре штуки --- тождественные ноль, единица, идентичная ($x$)и отрицание ($\lnot x$).

	Хотим найти функцию не сохраняющую ноль. Тут это только тождественная единица и отрицание икса. Это будет $f_i$

	Теперь хотим $h(x) --- f_j$ не сохраняющая единицу. Это отрицание или тождественный ноль. 

	Т.е. если возьмём функции не сохраняющие ноль и единицу, то или у нас есть сразу константы 0 и 1, или есть отрицание икса.  А теперь хотим получить, что на самом деле есть оба из них. Хотим из одного получать второе, а из второго --- первое.

	Пусть есть немонотонная функция $f_k$ и константы 0 и 1. Функция немонотонная, значит существует набор переменных $a_i$, среди которых есть ноль, на котором функция возвращает 1, а при замене нуля на единицу возвращает ноль. 

	Тогда возьмём функцию $g'(x)$, в которой все переменные $a_i$ поставим как константы, а на место нуля/единицы подставим $x$. Так получили отрицание.

	Теперь хотим из отрицания получить константы. У нас есть несамодвойственная функция $f_q$, тогда $\exists \{a_i\}$, что $f_q(a_1, a_2, \cdots, a_m) = f_q(\lnot a_1, \lnot a_2, \cdots, \lnot a_m)$. Тогда давайте построим функцию $g''(x)$ как $f_q(x, \lnot x, x, \cdots)$, где на позиции $i$, где $a_i = 1$ стоит $x$, а на противоположных --- $\lnot x$. Тогда мы получили функцию, которая что при $x$, что при $\lnot x$ выдаёт одно и то же, т.е. константа. А из одной можем получить вторую.

	Теперь к нелинейности. Функция нелинейна есть её полином Жегалкина нелинеен. Пусть $f_e(x_1, \cdots, x_m) = x_1 x_2 A(x_3, \cdots, x_m) \oplus x_1 B(x_3, \cdots, x_m) \oplus x_2 C(x_3, \cdots, x_m) \oplus D(x_3, \cdots, x_m) $, где $A, B, C, D$ --- произвольные многочлены Жегалкина, может и константы, но $A$ --- не тождественный ноль. Тогда можно пообрать такие $x_3, \cdots, x_m$, что $A(\cdots)$ равно единице. Тогда рассмотрим $f_e(x_1, x_2, a_3, \cdots, a_m) = \cdots$ восемь вариантов: 

	\begin{enumerate}
		\item{$x_1 x_2 \oplus x_1 \oplus x_2 \oplus d$}
		\item{$x_1 x_2 \oplus x_1 \oplus d$}
		\item{$x_1 x_2 \oplus x_2 \oplus d$}
		\item{$x_1 x_2 \oplus d$}
	\end{enumerate}

	Где $d$ --- какая-то константа. Но отрицанием можно убрать $\oplus d$. Теперь, если мы получили последнее, то мы получили $\land$ --- победа. Есть первое, что это $\lor$, что тоже победа. Второе есть $x_1 \land \lnot x_2$. Но отрицание мы умеем убирать, и так мы снова получим $\land$. А третье это буквально второе, с точностью до перестановки переменных. 
\end{proof}

Рассмотрим $f(x_1, x_2, x_3) = ((x_1 \land x_2) \oplus (x_3 \lor x_1)) ~ (x_1 \land x_2)$, где $~$ --- какая-то бинарная операция (в оригинале --- стрелка Пирса). Тогда можно составить схему, пока --- дерево  --- граф выполнения, где вершины --- операции или исходные переменные, а рёбра --- в переменные или результаты других операций, которые используются в нашей. 

А теперь сделаем не дерево, а просто ориентированный ациклический граф, где уберём все дублирования. 

\begin{definition}
	Схема --- ациклический граф, где из листьев --- значений входных параметров булевой схемы и вершин --- самих булевых операций, вычисляется значение всей булевой функции и подаётся на выход, в корень дерева. 
\end{definition}

Хотим жить в базисе $\land, \lor, \lnot$ (у нас будут только такие операции в схеме). Размер схемы --- количество внутренних узлов. 

\begin{definition}
	Схемная сложность функции --- размер схемы минимального размера. Да, она зависит от базиса, но на практике докажем:
\end{definition}

\begin{theorem}
	Схемная сложность в различных базисах отличается не более чем на константу раз.
\end{theorem}

\begin{theorem}
	$f: B^n \to B$. Тогда

	\begin{enumerate}
		\item{$size(f) \le \mathcal{O}(c^n) \forall c > 2$}
		\item{$\forall c < 2 \exists f : size(f) < c^n$}
	\end{enumerate}
\end{theorem}
\begin{proof}
	Для первого пункта --- построим КНФ, в нём, даже в другом базисе, строим схему размера $n \cdot 2^n$, что меньше, чем любое $(2 + \varepsilon)^n$ начиная с некоторого $n$. 
	
	Заметим, что функций от двух переменных у нас $2^{2^2} = 16$

	Пусть у нас $n$ переменных, и $N$ --- размер схемы.

	Тогда различных схем размера $N$ не больше $(16(n + N^2)^N) \le (64N^2)^N = (8N)^{2N} = 2^{2N \cdot \log 8N}$. Тепрь пусть $N = c^n$. Тогда получаем $2^{(\log 8c^4) 2c^n} \le 2^{c^n \cdot n \cdot const}$. Заменим левое на нечто большее --- $2^{(\log 8^n c^n) 2 c^n} \le 2^{c^n \cdot n \cdot \log 8c \cdot 2} < c\cdot 2^{2^n}$.

	Так мы каким то образом получили, что есть схемы, вычислимые за $(2+\varepsilon)^n$ но не вычислимые схемой размера $(2-\varepsilon)^n$.
\end{proof}

А вообще люди не умеют приводить пример функций, которые нельзя вычислить быстрее, чем за $4n$. Парадоксально. 

А теперь давайте придумывать схемы. Хотим сложить два числа $x_1 x_2 \cdots x_n$ и $y_1 y_2 \cdots y_n$ и получить $z_0 z_1 \cdots z_n$, если у нас есть $\land, \lor, \lnot, \oplus, 0, 1$. Понятно, что $z_n = x_n \oplus y_n$.  Пусть перенос --- $c_i$. Тогда $c_{n-1} = x_n \land y_n$. Тогда $z_{n-1} = x_{n-1} \oplus y_{n-1} \oplus c_{n-1}$. Если кто хочет нарисовать саму схему --- будем очень рады. $c_{n-2} = MAJ(x_{n-1}, y_{n-1}, c_{n-1})$, т.е. когда из аргументов есть хотя-бы две единицы. По сути, это $(x_{n-1} \land y_{n-1}) \lor (x_{n-1} \land c_{n-1}) \lor (y_{n-1} \land c_{n-1})$. Но какого размера будет схема? $\mathcal{O}(n)$.

\begin{definition}
	Глубина схемы --- длина самого длинного пути от входа до выхода. По сути, насколько быстро будут проходить вычисления. 
\end{definition}

Проблема нашей схемы --- её глубина $\mathcal{O}(n)$. 

\begin{theorem}
	Для сложения $n$-битных чисел существует схема размера $\mathcal{O}(n)$ и глубины $\mathcal{O}(\log n)$
\end{theorem}

Для доказательства этой теоремы нам потребуется ещё одна вещь. 

Пусть у нас есть два $n$ битных числа $\{x_i\}, \{y_i\}$, хотим понять, какое из них больше. Пусть у нас будут два гейта (внутренние вершины) $z_0, z_1$ и если выход --- два нуля, то $x < y$, если ноль один, то $x = y$, если один один, то $x > y$. Последний вариант игнорируем/ошибка/считаем равенством. 

Давайте сравним числа $x_1 x_2$ и $y_1 y_2$. Из неравенства между $x_1$ и $y_1$ следует неравенство ааа кто здесь между $x_1 x_2$ и $y_1 y_2$. В общем, на первом слое сравниваем единичные цифры, на втором --- пары, на третьем --- четвёрки подряд идущих блоков и так далее, получаем логарифм слоёв константной глубины. Ну в общем там немного иначе, поправьте кто-нибудь пж. Каждый раз мы сравниваем результаты предыдущих слоёв, а не сравнивать все 4/8/16... битов. 

Полученный результат можно использовать для получения бита переноса --- бит переноса $c_i$ есть, если число $x_i x_{i+1} \cdots x_n$ больше, чем $1-y_i 1-y_{i+1} \cdots 1-y_n$. 

\begin{theorem}
	Пусть есть $x_1 x_2 \cdots x_n$ и хотим получить сумму этих $n$ бит и записать их в виде числа $y_1 y_2 \cdots y_{\log n}$. Это можно сделать схемой размера $\mathcal{O}(n)$ и глубины $\mathcal{O}(\log n \log \log n)$
\end{theorem}
